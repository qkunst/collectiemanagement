# frozen_string_literal: true

# Like the creator of formtastic, I was unsatisfied with the default view-html generated by rails.
# These helper methods help cleaning it up a bit.
#
# DSL:
#
#    <% definition_list_for @obj do %>
#        <%= define_unless_blank :main_category %>
#        <%= define_unless_blank :sub_category %>
#        <%= define_unless_blank :description %>
#        <%= define_unless_blank :conversion_factor %>
#        <%= define_unless_blank :turnover, {modifier: :number_to_currency} %>
#    <% end %>
module DefineTasticHelper
  def render_unless_blank_definition description, value, options = {}
    classname = options[:classname]
    if @define_tastic_render_as == :table
      style = " style=\"width: #{@define_tastic_key_width}\"" if @define_tastic_key_width
      "<tr#{" class=\"#{classname}\"" if classname}><th#{style}>#{description}:</th><td>#{sanitize value}</td></tr>".html_safe unless value.blank?
    else
      "<dt#{" class=\"#{classname}\"" if classname}>#{description}:</dt><dd#{" class=\"#{classname}\"" if classname}>#{sanitize value}</dd>".html_safe unless value.blank?
    end
  end

  def sanctioned_define_unless_blank property, options = {}
    if current_user.admin? || current_user.viewable_work_fields.include?(property)
      define_unless_blank property, options
    end
  end

  def define_unless_blank property, options = {}
    description = options[:description] || @define_tastic_object_klass.human_attribute_name(property)

    render_unless_blank_definition(description, value_render(property, options), options)
  end

  def humanize_value val, options = {}
    if val.is_a?(ActiveRecord::Base) && (val.methods.include?(:name) || val.methods.include?("name"))
      val = val.name
    end
    if val.is_a? Date
      val = I18n.l(val, format: :short)
    elsif val.is_a?(DateTime) || val.is_a?(Time)
      val = I18n.l(val, format: :short)
    elsif val.is_a? TrueClass
      val = "Ja"
    elsif val.is_a? FalseClass
      val = "Nee"
    end
    if options[:humanize_attribute_value]
      val = @define_tastic_object_klass.send(:human_attribute_name, val)
    end
    val
  end

  def value_render property, options = {}
    value = nil

    if options[:override_value]
      value = options[:override_value]
    else
      modifier_func = options[:modifier]
      humanize_attribute_value = options[:humanize_attribute_value]

      value = if property.is_a? Symbol
        @define_tastic_object.public_send(property)
      else
        property
      end

      value = if value.is_a?(Range)
        [value.min, value.max].map { |value|
          apply_modifier_to_value_and_humanize(modifier_func, value, humanize_attribute_value)
        }.join("-")
      elsif value.is_a?(Enumerable)
        value.to_a.compact.map { |value|
          apply_modifier_to_value_and_humanize(modifier_func, value, humanize_attribute_value)
        }.to_sentence
      else
        apply_modifier_to_value_and_humanize(modifier_func, value, humanize_attribute_value).to_s
      end
    end
    value.html_safe
  end

  def apply_modifier_to_value modifier, value, obj = self
    if value && modifier
      return obj.public_send(modifier, value)
    end
    value
  end

  def apply_modifier_to_value_and_humanize(modifier_func, value, humanize_attribute_value)
    humanize_value(
      apply_modifier_to_value(modifier_func, value),
      {humanize_attribute_value: humanize_attribute_value}
    )
  end

  def upcase value
    value.to_s.upcase
  end

  def link_to_with_name object, options = {}
    options = {nil_value: "-"}.merge(options)
    subject = if object.instance_of?(Array)
      object.last
    else
      object
    end

    name = options[:nil_value]
    name = subject.name if subject.methods.include? :name
    name = subject.title if subject.methods.include? :title

    object ? link_to(name, object) : options[:nil_value]
  end

  def definition_list_for(object, *args, &)
    @define_tastic_object = object
    @define_tastic_object_klass = object.class
    @define_tastic_render_as = :dl

    if args[0].is_a? Hash
      if args[0][:render_as]
        @define_tastic_render_as = (args[0][:render_as] == :table) ? :table : :dl
      end
      if args[0][:key_width]
        @define_tastic_key_width = args[0][:key_width]
      end
    end

    block_contents = capture(&).to_s

    html_string = block_contents.strip.empty? ? "" : ["<#{@define_tastic_render_as}>", block_contents, "</#{@define_tastic_render_as}>"].join("\n")

    @define_tastic_object = object
    @define_tastic_object_klass = nil

    html_string.html_safe
  end
end

#
# # Like the creator of formtastic, I was unsatisfied with the default view-html generated by rails.
# # These helper methods help cleaning it up a bit.
# #
# # DSL:
# #
# #    <% definition_list_for @obj do %>
# #        <%= define_unless_blank :main_category %>
# #        <%= define_unless_blank :sub_category %>
# #        <%= define_unless_blank :description %>
# #        <%= define_unless_blank :conversion_factor %>
# #        <%= define_unless_blank :turnover, nil, {:modifier=>:number_to_currency} %>
# #    <% end %>
#
#
#   def render_unless_blank_definition description, value
#     "<dt>#{description}:</dt><dd>#{value}</dd>" unless value.blank?
#   end
#
#   def define_unless_blank property, description=nil, options={}
#     description = @object_klass.human_attribute_name(property) unless description
#     value = @object.read_attribute property
#     modifier = options[:modifier]
#     value = eval "#{modifier} '#{value}'" unless value.blank?
#     render_unless_blank_definition(description, value)
#   end
#
#   def link_to_with_name object
#     if object.class == Array
#       subject = object.last
#     else
#       subject = object
#     end
#
#     name = "geen naam opgegeven"
#     name = subject.name if subject.has_attribute? :name
#     name = subject.title if subject.has_attribute? :title
#     return link_to(name, object)
#   end
#
#
#   def definition_list_for object, *args, &block
#     @object = object
#     @object_klass = object.class
#     if args[0]
#       concat('<h3>'.html_safe)
#       concat(args[0])
#       concat('</h3>'.html_safe)
#     end
#     concat('<dl>'.html_safe) #inpsired by the form_for helper
#     fields_for(object, *(args), &proc)
#     concat('</dl>'.html_safe)
#   end
